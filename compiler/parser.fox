import "lexer";
import "array";

ParserRule :: class
{
	init(prefix, infix, precedence)
	{
		this.prefix = prefix;
		this.infix = infix;
		this.precedence = precedence;
	}
}

rules: var = Array();
for (i: var = 0; i < MAX_TOKEN; i = i +1)
{
	rules.push(ParserRule(nil, nil, 0));
}

pRoot: var = Array();

Unary :: func(can_assign)
{
	operatorType: var = parser.previousToken.getType();
    ParsePrecedence(PREC_UNARY);
	// if (operatorType == BANG)
	//	pRoot.push(Type("+"));
    // else
	if (operatorType == MINUS)
		pRoot.push(Type("-"));
}

Binary :: func(can_assign)
{
	operatorType: var = parser.previousToken.getType();
    rule: var = GetRule(operatorType);
    ParsePrecedence(rule.precedence + 1);

    if (operatorType == PLUS)
		pRoot.push(SumExpression(pRoot.pop(), pRoot.pop()));
    else if (operatorType == MINUS)
		pRoot.push(SubtractionExpression(pRoot.pop(), pRoot.pop()));
    else if (operatorType == STAR)
		pRoot.push(MultiplicationExpression(pRoot.pop(), pRoot.pop()));
    else if (operatorType == SLASH)
		pRoot.push(DivisionExpression(pRoot.pop(), pRoot.pop()));
}

Grouping :: func(can_assign)
{
	
}

Identifier :: func(can_assign)
{
	
}

Number :: func(can_assign)
{
	pRoot.push(Type(parser.previousToken.getText()));
}

// Binary Op
rules.set(MINUS, ParserRule(Unary, Binary, PREC_TERM));
rules.set(PLUS, ParserRule(nil, Binary, PREC_TERM));
rules.set(STAR, ParserRule(nil, Binary, PREC_FACTOR));
rules.set(SLASH, ParserRule(nil, Binary, PREC_FACTOR));

// Paren
rules.set(LEFT_PAREN, ParserRule(Grouping, nil, PREC_CALL));
rules.set(RIGHT_PAREN, ParserRule(nil, nil, PREC_NONE));

// Types
rules.set(IDENTIFIER, ParserRule(Identifier, nil, PREC_NONE));
rules.set(NUMBER, ParserRule(Number, nil, PREC_NONE));

GetRule :: func(type)
{
	if (type > 0)
    	return rules.get(type);
	else
		return nil;
}

ParsePrecedence :: func(precedence)
{
    parser.NextToken();
    pRule: var = GetRule(parser.previousToken.getType());
    prefix_rule: var = pRule.prefix;
    if (prefix_rule == nil) {
        parser.Error("Expect expression.");
        return;
    }
    can_assign: var = precedence <= PREC_ASSIGNMENT;
    prefix_rule(can_assign);

	pRule = GetRule(parser.currentToken.getType());
    while (pRule != nil && precedence <= pRule.precedence && parser.previousToken.getText() != nil) {
        parser.NextToken();
        infix_rule: var = GetRule(parser.previousToken.getType()).infix;
		if (infix_rule != nil)
        	infix_rule(can_assign);
		pRule = GetRule(parser.currentToken.getType());
    }

    // if (can_assign && parser.Match(TOKEN_EQUAL)) {
    //    parser.Error("Invalid assignment target.");
    // }
}

Expression :: func()
{
    ParsePrecedence(PREC_ASSIGNMENT);
}

Parser :: class
{
	init()
	{
		this.m_oLexer = Lexer();
		this.previousToken = nil;
		this.currentToken = nil;
		this.panicMode = false;
		this.hadError = false;
	}

	Define(id, string, addToList)
	{
		this.m_oLexer.Define(id, string, addToList);
	}

	Process(string)
	{
		return this.m_oLexer.Process(string);
	}

	Dump()
	{
		this.m_oLexer.Dump();
	}

	NextToken()
	{
		this.previousToken = this.currentToken;
		parse: var = true;
		while (parse)
		{
			this.currentToken = this.m_oLexer.NextToken();
			if (this.currentToken.getType() != 84) {
				return;
			}
			ErrorAtCurrent(this.currentToken.getText());
		}
	}

	AdvanceToken(advance)
	{
		errorType: var = 84;
		if (this.currentToken.getType() == errorType)
		{
			ErrorAtCurrent(this.currentToken.getText());
			return;
		}

		if (advance)
		{
			this.NextToken();
		}
	}

	IsTokenType(type, bAdvance)
	{
		if (this.currentToken.getType() == type) {
			if (bAdvance)
				this.NextToken();
			return (true);
		}
		return (false);
	}

	GetNext()
	{
		this.NextToken();
		return this.previousToken;
	}

	IsToken(iType, value, bAdvance)
	{
		if (this.currentToken.getType() == iType && this.m_oLexer.TokenMatch(this.currentToken, value))
		{
			if (bAdvance)
				this.NextToken();
			return true;
		}
		return false;
	}

	IsTokenThenAssign(iType, value, bAdvance)
	{
		if (this.currentToken.getType() == iType && this.m_oLexer.TokenMatch(this.currentToken, value))
		{
			// oToken = this.currentToken;
			if (bAdvance)
				this.NextToken();
			return true;
		}
		return false;
	}

	PeekTokenIsType(iType)
	{
		return (this.currentToken.getType() == iType);
	}
	
	/*
	PeekNextTokenIsType(int iType)
	{
		return (this.m_oLexer.PeekNextToken().getType() == iType);
	}
	*/

	PeekTokenIs(s)
	{
		return this.m_oLexer.TokenMatch(this.currentToken, s);
	}

	ErrorAtCurrent(message)
	{
		this.ErrorAt(this.currentToken, message);
	}

	Error(message)
	{
		this.ErrorAt(this.previousToken, message);
	}

	ErrorAt(token, message)
	{
		if (!this.panicMode)
		{
			this.panicMode = true;
			print "[line %] Error", token.getLine();

			errorType: var = 84;
			if (token.getType() != errorType) {
				print " at '%s'", token.m_strText;
			}

			print ": %\n", message;
			this.hadError = true;
		}
	}

	ParseCode()
	{
		newNode: var = nil;
		oName: var = nil;

		if (this.IsTokenType(NUMBER, false))
		{
			newNode = Type(this.GetNext().getText());
		}
		
		return (newNode);
	}

	GenAst(strText)
	{
		parsing: var = true;

		if (!this.Process(strText))
			return nil;

		this.m_oLexer.Begin();
		this.NextToken();
		Expression();
		
		return pRoot;
	}
}

parser: var = Parser();